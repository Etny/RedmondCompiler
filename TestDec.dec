#Grammar

left + -
left * /
left OR AND
left CGT CLT CEQ NEQ
none precToken
left .
none ELSE
none [
none RANK_SPECIFIER

%%

file				
					:	import_list namespace_declarations	{$$ = makeNode("File", $1, $2)}
					;

import_list			
					:	import_list import_dec	{addChild($1, $2); $$ = $1}
					|	import_dec				{$$ = makeNode("ImportList", $1)}
					|							{$$ = makeNode("ImportList")}
					;

import_dec			
					:	USING qualified_identifier ';'	{$$ = makeNode("Import", $2)}
					;

namespace_declarations
					:	namespace_declarations namespace_declaration	{addChild($1, $2); $$ = $1}
					|	namespace_declaration							{$$ = makeNode("NamespaceList", $1)}
					|													{$$ = makeNode("NamespaceList")}
					;

namespace_declaration
					:	NAMESPACE qualified_identifier '\{' class_list '\}'	{$$ = makeNode("NamespaceDec", $2, $4)}
					;

class_list			
					:	class_list class_dec	{addChild($1, $2); $$ = $1}
					|	class_dec				{$$ = makeNode("ClassList", $1)}
					|							{$$ = makeNode("ClassList")}
					;

class_dec			
					:	CLASS IDENTIFIER '\{' member_list '\}' {$$ = makeNode("Class", $2, $4)}
					;

member_list			
					:	member_list member	{addChild($1, $2); $$ = $1}
					|	member				{$$ = makeNode("MemberList", $1)}
					|						{$$ = makeNode("MemberList")}
					;

member				
					:	field
					|	function
					|	constructor
					;

member_header		
					:	access_dec modifier_list type	{$$ = makeNode("DecHeader", $1, $2, $3)}
					;

field				
					:	member_header IDENTIFIER EQ expression ';'		{$$ = makeNode("FieldDec", $1, $2, $4)}
					|	member_header IDENTIFIER ';'					{$$ = makeNode("FieldDec", $1, $2)}
					;

constructor			
					:	constructor_dec function_body	{$$ = makeNode("Constructor", $1, $2)}
					;

constructor_dec		
					:	member_header '\(' parameter_dec_list '\)' {$$ = makeNode("ConstructorDec", $1, $3)}
					;

function			
					:	function_dec function_body	{$$ = makeNode("Function", $1, $2)}
					;

function_dec		
					:	member_header IDENTIFIER '\(' parameter_dec_list '\)' {$$ = makeNode("FunctionDec", $1, $2, $4)}
					;

access_dec			
					:	PUBLIC		{$$ = makeLeaf("AccessKeyword", "public")}
					|	PRIVATE		{$$ = makeLeaf("AccessKeyword", "private")}	
					|	PROTECTED	{$$ = makeLeaf("AccessKeyword", "family")}
					|	INTERNAL	{$$ = makeLeaf("AccessKeyword", "assembly")}
					|				{$$ = makeLeaf("AccessKeyword", "assembly")}
					;

modifier_list		
					:	modifier_list modifier	{addChild($1, $2); $$ = $1}
					|	modifier				{$$ = makeNode("ModifierList", $1)}
					|							{$$ = makeNode("ModifierList")}
					;

modifier			
					:	SEALED		{$$ = makeLeaf("Modifier", "sealed")}
					|	STATIC		{$$ = makeLeaf("Modifier", "static")}
					|	ABSTRACT	{$$ = makeLeaf("Modifier", "abstract")}
					|	VIRTUAL		{$$ = makeLeaf("Modifier", "virtual")}
					|	CONST		{$$ = makeLeaf("Modifier", "literal")}
					|	READONLY	{$$ = makeLeaf("Modifier", "initonly")}
					;

function_body		
					:	compound_statement				{$$ = makeNode("FunctionBody", $1)}
					|	'=>' statement					{$$ = makeNode("FunctionBody", $3)}
					;


compound_statement	
					:	'\{' statement_list '\}'	{$$ = makeNode("CompoundStatement", $2);}
					;

statement_list		
					:	statement_list statement	{addChild($1, $2); $$ = $1}
					|	statement					{$$ = makeNode("StatementList", $1);}
					|								{$$ = makeNode("StatementList");}
					;

statement			
					:	assign_statement ';'	{$$ = $1}
					|	call_statement ';'	{$$ = $1}
					|	dec_statement ';'		{$$ = $1}
					|	return_statement ';'	{$$ = $1}
					|	statement_expression ';' {$$ = makeNode("ExpressionStatement", $1)}
					|	compound_statement
					|	if_statement
					|	while_statement
					|	for_statement
					;

return_statement	
					:	RETURN				{$$ = makeLeaf("ReturnStatement")}
					|	RETURN expression	{$$ = makeNode("ReturnStatement", $2)}
					;

dec_statement		:	type IDENTIFIER EQ expression	{$$ = makeNode("DeclarationStatement", $2, $1, $4);}
					|	type IDENTIFIER					{$$ = makeNode("DeclarationStatement", $2, $1)}  
					;

assign_statement	
					: unary_expression EQ expression			{$$ = makeNode("AssignExpression", $1, $3)}
					;

if_statement		
					:	IF parenthesized_expression statement ELSE statement	{$$ = makeNode("IfElseStatement", $2, $3, $5)}
					|	IF parenthesized_expression statement					{$$ = makeNode("IfStatement", $2, $3)}
					;

while_statement		
					:	WHILE parenthesized_expression statement			{$$ = makeNode("WhileStatement", $2, $3)}
					|	DO statement WHILE parenthesized_expression ';'	{$$ = makeNode("DoWhileStatement", $4, $2)}
					;

for_statement		
					:	FOR	'\(' for_initializer ';' for_condition ';' for_iterator '\)' statement	{$$ = makeNode("ForStatement", $3, $5, $7, $9)}
					;

for_initializer
					:	dec_statement
					|	statement_expression_list
					|	{$$ = makeLeaf("Empty")}
					;

for_condition		:	expression
					|	{$$ = makeLeaf("Empty")}
					;

for_iterator		:	statement_expression_list
					|	{$$ = makeLeaf("Empty")}
					;

call_statement		
					:	primary_expression_no_parenthesis '\(' parameter_list '\)' {$$ = makeNode("Call", $1, $3)}
					|	qualified_identifier '\(' parameter_list '\)' {$$ = makeNode("Call", $1, $3)}
					;

parameter_list		
					:	parameter_list ',' expression		{addChild($1, $3); $$ = $1}
					|	expression					{$$ = makeNode("ParameterList", $1)}
					|								{$$ = makeNode("ParameterList")}
					;

parameter_dec_list	
					:	parameter_dec_list ',' parameter_dec		{addChild($1, $3); $$ = $1}
					|	parameter_dec								{$$ = makeNode("ParameterDecList", $1)}
					|											{$$ = makeNode("ParameterDecList")}
					;

parameter_dec		
					:	type IDENTIFIER			{$$ = makeNode("ParameterDec", $1, $2)}
					;

array_dec_expression
					:	NEW type '[' expression ']'						{$$ = makeNode("NewArrayExpression", $2, $4)}
					|	NEW array_type array_init_expression		{$$ = makeNode("NewArrayExpression", $2, $3)}
					|	array_init_expression									{$$ = makeNode("NewArrayExpression", $1)}
					;

new_expression
					:	NEW non_array_type '\(' parameter_list '\)'	{$$ = makeNode("NewExpression", $2, $4)}
					;

statement_expression
					:	assign_statement
					|	post_inc_or_dec_expression
					|	new_expression
					;

statement_expression_list
					:	statement_expression								{$$ = makeNode("StatementExpressionList", $1)}
					|	statement_expression_list ',' statement_expression	{addChild($1, $3); $$ = $1}
					;


array_init_expression		
					:	'\{' parameter_list '\}' {$$ = $2}
					;

array_access_expression
					:	qualified_identifier '[' expression ']'	{$$ = makeNode("ArrayAccessExpression", $1, $3)}
					|	primary_expression '[' expression ']'	{$$ = makeNode("ArrayAccessExpression", $1, $3)}
					;

literal_expression
					:	StringLiteral							{$$ = makeLeaf("StringLiteral", $1)}
					|	CharLiteral								{$$ = makeLeaf("CharLiteral", $1)}
					|	BoolLiteral								{$$ = makeLeaf("BoolLiteral", $1)}
					|	Digit									{$$ = makeLeaf("NumericalLiteral", $1}
					;

binary_expression	
					:	binary_expression '+' unary_expression				{$$ = makeNode("BinaryExpression", $1, $3, makeLeaf("BinaryOperator", "Add"));}
					|	binary_expression '-' unary_expression				{$$ = makeNode("BinaryExpression", $1, $3, makeLeaf("BinaryOperator", "Sub"));}
					|	binary_expression '/' unary_expression				{$$ = makeNode("BinaryExpression", $1, $3, makeLeaf("BinaryOperator", "Div"));}
					|	binary_expression '*' unary_expression				{$$ = makeNode("BinaryExpression", $1, $3, makeLeaf("BinaryOperator", "Mul"));}
					|	unary_expression
					;
					
relational_expression
					:	relational_expression CEQ binary_expression				{$$ = makeNode("BinaryBoolExpression", $1, $3, makeLeaf("BinaryBooleanOperator", "Ceq"))}
					|	relational_expression NEQ binary_expression				{$$ = makeNode("BinaryBoolExpression", $1, $3, makeLeaf("BinaryBooleanOperator", "Neq"))}
					|	relational_expression CLT binary_expression				{$$ = makeNode("BinaryBoolExpression", $1, $3, makeLeaf("BinaryBooleanOperator", "Clt"))}
					|	relational_expression CGT binary_expression				{$$ = makeNode("BinaryBoolExpression", $1, $3, makeLeaf("BinaryBooleanOperator", "Cgt"))}
					|	binary_expression
					;

conditional_expression
					:	conditional_expression AND relational_expression				{$$ = makeNode("BoolCheckExpression", $1, $3, makeLeaf("BooleanCheckOperator", "And"))}
					|	conditional_expression OR relational_expression				{$$ = makeNode("BoolCheckExpression", $1, $3, makeLeaf("BooleanCheckOperator", "Or"))}
					|	relational_expression
					;

primary_expression_no_parenthesis
					:	literal_expression
					|	array_dec_expression
					|	member_access
					|	call_statement							{$$ = makeNode("CallExpression", $1)}
					|	array_access_expression
					|   new_expression
					;


primary_expression	
					:	parenthesized_expression
					|	primary_expression_no_parenthesis
					;

expression
					:	conditional_expression
					|	assign_statement
					;

unary_expression	
					:	postfix_expression
					;

post_inc_or_dec_expression
					:	postfix_expression PLUSPLUS		{$$ = makeNode("PostIncOrDec", $1, makeLeaf("BinaryOperator", "Add"))}
					|	postfix_expression MINUSMINUS	{$$ = makeNode("PostIncOrDec", $1, makeLeaf("BinaryOperator", "Sub"))}
					;

postfix_expression	
					:	qualified_identifier
					|	primary_expression
					|	post_inc_or_dec_expression
					;


parenthesized_expression	
					:	'\(' expression '\)'	{$$ = $2}
					;

					
member_access		
					:	primary_expression '.' IDENTIFIER	{$$ = makeNode("MemberAccess", $1, $3)}
					;


type	
					:	array_type
					|	non_array_type
					;

array_type	
					:	qualified_identifier RANK_SPECIFIER	{$$ = makeNode("Array", $1)}
					;

non_array_type		
					:	type_name
					;

type_name			
					:	qualified_identifier
					;

qualified_identifier
					:	IDENTIFIER					{$$ = makeNode("QualifiedIdentifier", $1}
					|	qualifier IDENTIFIER		{$$ = makeNode("QualifiedIdentifier", $1, $2)}
					;
qualifier
					:	IDENTIFIER '.'			{$$ = makeNode("Qualifier", $1)}
					|	qualifier IDENTIFIER '.'	{$$ = makeNode("Qualifier", $1, $2)}
					;





#End

#Settings
	
PrecedenceSearchDepth: 1
AutoValueInheritance: true

#end

#Tokens

IDENTIFIER
Operator
Punctuation
Digit
Whitespace
NewLine
StringLiteral
BoolLiteral
CharLiteral

STATIC
PUBLIC
PRIVATE
INTERNAL
PROTECTED
SEALED
VIRTUAL
ABSTRACT
READONLY
CONST
CLASS
NAMESPACE
USING
RETURN
NEW
IF
ELSE
WHILE
DO
FOR

PLUSPLUS MINUSMINUS

EQ
CEQ
CLT
CGT
NEQ
AND
OR

RANK_SPECIFIER

#End

#Lex


letter = [a-zA-Z]
number = [0-9]
character = letter|number|_

%%

static		{STATIC}
public		{PUBLIC}
private		{PRIVATE}
protected	{PROTECTED}
sealed		{SEALED}
virtual		{VIRTUAL}
abstratc	{ABSTRACT}
readonly	{READONLY}
const		{CONST}
class		{CLASS}
namespace	{NAMESPACE}
using		{USING}
return		{RETURN}
new			{NEW}
if			{IF}
else		{ELSE}
while		{WHILE}
do			{DO}
for			{FOR}

\+\+		{PLUSPLUS}
\-\-		{MINUSMINUS}

\&\&		{AND}
\|\|		{OR}
==			{CEQ}
!=			{NEQ}
>			{CGT}
<			{CLT}
=			{EQ}

\[[\w\t\r\n]*\]		{RANK_SPECIFIER}

true												{BoolLiteral; $$.type = "bool"; $$ = makeValue("bool", parseBool($))}
(letter|_)character*								{IDENTIFIER; $$ = makeLeaf("Identifier", $); $$.text = $}
number+												{Digit; $$.num = parseInt($); $$.type = "int"; $$ = makeValue("int32", parseInt($));}
[=\*/+-]											{Operator}
[,();:>.,\{\}\[\]]									{Punctuation}
[\w\t\r\n]											{Whitespace}
\'character\'										{CharLiteral; $$ = makeValue("char", parseChar($))}
"((letter|number)|[\w\t\r\n:,!/\(\)?\'])*"			{StringLiteral; $$ = makeValue("string", $)}

#End