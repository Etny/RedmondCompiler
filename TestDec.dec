#Grammar

left + -
left * /
none precToken
none ELSE

%%

file				:	import_list class_list	{$$ = makeNode("File", $1, $2)}
					;

import_list			:	import_list import_dec	{addChild($1, $2); $$ = $1}
					|	import_dec				{$$ = makeNode("ImportList", $1)}
					|							{$$ = makeNode("ImportList")}
					;

import_dec			:	USING space_or_type_name ';'	{$$ = makeLeaf("Import", $2.name)}
					;

class_list			:	class_list class_dec	{addChild($1, $2); $$ = $1}
					|	class_dec				{$$ = makeNode("ClassList", $1)}
					|							{$$ = makeNode("ClassList")}
					;

class_dec			:	CLASS IDENTIFIER '\{' member_list '\}' {$$ = makeNode("Class", $2, $4)}
					;

member_list			:	member_list member	{addChild($1, $2); $$ = $1}
					|	member				{$$ = makeNode("MemberList", $1)}
					|						{$$ = makeNode("MemberList")}
					;

member				:	field
					|	function
					|	constructor
					;

member_header		:	access_dec modifier_list type_name	{$$ = makeNode("DecHeader", $1, $2, $3)}
					;

field				:	member_header IDENTIFIER EQ expression ';'		{$$ = makeNode("FieldDec", $1, $2, $4)}
					|	member_header IDENTIFIER ';'					{$$ = makeNode("FieldDec", $1, $2)}
					;

constructor			:	constructor_dec function_body	{$$ = makeNode("Constructor", $1, $2)}
					;

constructor_dec		:	member_header '\(' parameter_dec_list '\)' {$$ = makeNode("ConstructorDec", $1, $3)}
					;

function			:	function_dec function_body	{$$ = makeNode("Function", $1, $2)}
					;

function_dec		:	member_header IDENTIFIER '\(' parameter_dec_list '\)' {$$ = makeNode("FunctionDec", $1, $2, $4)}
					;

access_dec			:	PUBLIC		{$$ = makeLeaf("AccessKeyword", "public")}
					|	PRIVATE		{$$ = makeLeaf("AccessKeyword", "private")}	
					|	PROTECTED	{$$ = makeLeaf("AccessKeyword", "family")}
					|	INTERNAL	{$$ = makeLeaf("AccessKeyword", "assembly")}
					|				{$$ = makeLeaf("AccessKeyword", "assembly")}
					;

modifier_list		:	modifier_list modifier	{addChild($1, $2); $$ = $1}
					|	modifier				{$$ = makeNode("ModifierList", $1)}
					|							{$$ = makeNode("ModifierList")}
					;

modifier			:	SEALED		{$$ = makeLeaf("Modifier", "sealed")}
					|	STATIC		{$$ = makeLeaf("Modifier", "static")}
					|	ABSTRACT	{$$ = makeLeaf("Modifier", "abstract")}
					|	VIRTUAL		{$$ = makeLeaf("Modifier", "virtual")}
					|	CONST		{$$ = makeLeaf("Modifier", "literal")}
					|	READONLY	{$$ = makeLeaf("Modifier", "initonly")}
					;

function_body		:	compound_statement				{$$ = makeNode("FunctionBody", $1)}
					|	'=>' statement					{$$ = makeNode("FunctionBody", $3)}
					;


compound_statement	:	'\{' statement_list '\}'	{$$ = makeNode("CompoundStatement", $2);}
					;

statement_list		:	statement_list statement	{addChild($1, $2); $$ = $1}
					|	statement					{$$ = makeNode("StatementList", $1);}
					|								{$$ = makeNode("StatementList");}
					;


statement			:	assign_statement ';'	{$$ = $1}
					|	call_statement ';'	{$$ = $1}
					|	dec_statement ';'		{$$ = $1}
					|	return_statement ';'	{$$ = $1}
					|	compound_statement
					|	if_statement
					|	while_statement
					|	for_statement
					;

return_statement	:	RETURN				{$$ = makeLeaf("ReturnStatement")}
					|	RETURN expression	{$$ = makeNode("ReturnStatement", $2)}
					;

dec_statement		:	space_or_type_name IDENTIFIER EQ expression	{$$ = makeNode("DeclarationStatement", $2, $1, $4);}
					|	space_or_type_name IDENTIFIER					{$$ = makeNode("DeclarationStatement", $2, $1)}  
					;

assign_statement	:	IDENTIFIER EQ expression		{$$ = makeNode("AssignStatement", $1, $3)}
					|	member_access EQ expression	{$$ = makeNode("AssignStatement", $1, $3)}
					;

if_statement		:	IF parenthesized_exp statement ELSE statement	{$$ = makeNode("IfElseStatement", $2, $3, $5)}
					|	IF parenthesized_exp statement					{$$ = makeNode("IfStatement", $2, $3)}
					;

while_statement		:	WHILE parenthesized_exp statement	{$$ = makeNode("WhileStatement", $2, $3)}
					|	DO statement WHILE parenthesized_exp	{$$ = makeNode("DoWhileStatement", $4, $2)}
					;

for_statement		:	FOR	'\(' dec_statement ';' expression ';' assign_statement '\)' statement	{$$ = makeNode("ForStatement", $3, $5, $7, $9)}
					;

call_statement		:	expression '.' IDENTIFIER '\(' parameter_list '\)' {$$ = makeNode("Call", $3, $5, $1)}
					|	 IDENTIFIER '\(' parameter_list '\)' {$$ = makeNode("Call", $1, $3)}
					;

parameter_list		:	parameter_list ',' expression		{addChild($1, $3); $$ = $1}
					|	expression					{$$ = makeNode("ParameterList", $1)}
					|								{$$ = makeNode("ParameterList")}
					;

parameter_dec_list	:	parameter_dec_list ',' parameter_dec		{addChild($1, $3); $$ = $1}
					|	parameter_dec								{$$ = makeNode("ParameterDecList", $1)}
					|											{$$ = makeNode("ParameterDecList")}
					;

parameter_dec		:	space_or_type_name IDENTIFIER			{$$ = makeNode("ParameterDec", $1, $2)}
					;

expression			:	Digit									{$$ = makeLeaf("NumericalLiteral", $1);}
					|	StringLiteral							{$$ = makeLeaf("StringLiteral", $1)}
					|	BoolLiteral								{$$ = makeLeaf("BoolLiteral", $1)}
					|	IDENTIFIER								{$$ = makeLeaf("IdentifierExpression", $1)}
					|	expression binop expression				{$$ = makeNode("BinaryExpression", $1, $3, $2);}
					|	parenthesized_exp						{$$ = $1}
					|	call_statement							{$$ = makeNode("CallExpression", $1)}
					|	member_access							{$$ = $1}
					|   NEW type_name '\(' parameter_list '\)'	{$$ = makeNode("NewExpression", $2, $4)}
					;

parenthesized_exp	:	'\(' expression '\)'	{$$ = $2}
					;

					
member_access		:	expression '.' IDENTIFIER	{$$ = makeNode("MemberAccess", $3, $1)}
					;

space_or_type_name	:	IDENTIFIER							{$$ = makeLeaf("Name", $1.text); $$.name = $1.text}
					|	space_or_type_name '.' IDENTIFIER	{$$.name = concat($1.name, concat(".", $3.text)); $$ = makeLeaf("Name", $$.name)}
					;

type_name			:	space_or_type_name
					;

binop				:	'+'		{$$ = makeLeaf("BinaryOperator", "Add")}
					|	'-'		{$$ = makeLeaf("BinaryOperator", "Sub")}
					|	'/'		{$$ = makeLeaf("BinaryOperator", "Div")}
					|	'*'		{$$ = makeLeaf("BinaryOperator", "Mul")}
					|	CEQ		{$$ = makeLeaf("BinaryOperator", "Ceq")}
					|	CGT		{$$ = makeLeaf("BinaryOperator", "Cgt")}
					|	CLT		{$$ = makeLeaf("BinaryOperator", "Clt")}
					|	NEQ		{$$ = makeLeaf("BinaryOperator", "Neq")}
					;



#End

#Settings
	
PrecedenceSearchDepth: 1
AutoValueInheritance: true

#end

#Tokens

IDENTIFIER
Operator
Punctuation
Digit
Whitespace
NewLine
StringLiteral
BoolLiteral

STATIC
PUBLIC
PRIVATE
INTERNAL
PROTECTED
SEALED
VIRTUAL
ABSTRACT
READONLY
CONST
CLASS
USING
RETURN
NEW
IF
ELSE
WHILE
DO
FOR

EQ
CEQ
CLT
CGT
NEQ

#End

#Lex

letter = [a-zA-Z]
number = [0-9]
character = letter|number|_

%%

static		{STATIC}
public		{PUBLIC}
private		{PRIVATE}
protected	{PROTECTED}
sealed		{SEALED}
virtual		{VIRTUAL}
abstratc	{ABSTRACT}
readonly	{READONLY}
const		{CONST}
class		{CLASS}
using		{USING}
return		{RETURN}
new			{NEW}
if			{IF}
else		{ELSE}
while		{WHILE}
do			{DO}
for			{FOR}

==			{CEQ}
!=			{NEQ}
>			{CGT}
<			{CLT}
=			{EQ}

true {BoolLiteral; $$.type = "bool"; $$ = makeValue("bool", parseBool($))}
(letter|_)character* {IDENTIFIER; $$ = makeLeaf("Identifier", $); $$.text = $}
number+ {Digit; $$.num = parseInt($); $$.type = "int"; $$ = makeValue("int32", parseInt($));}
[=\*/+-] {Operator}
[,();:>.,\{\}] {Punctuation}
[\w\t\r\n]	{Whitespace}
"((letter|number)|[\w\t\r\n:,])*"	{StringLiteral; $$ = makeValue("string", $)}

#End